<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Three.js FPS Minimal</title>
<style>
body { margin:0; overflow:hidden; }
canvas { display:block; }
#crosshair {
  position:absolute; top:50%; left:50%;
  width:10px; height:10px;
  margin-left:-5px; margin-top:-5px;
  border:2px solid black; border-radius:50%;
  pointer-events:none; z-index:10;
}
#score { position:absolute; top:10px; left:10px; font-size:24px; color:white; z-index:10; }
</style>
</head>
<body>
<div id="crosshair"></div>
<div id="score">Score: 0</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);

const camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
camera.position.set(0,1.6,10);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

// Light
scene.add(new THREE.AmbientLight(0xffffff,1));
const dirLight = new THREE.DirectionalLight(0xffffff,0.5);
dirLight.position.set(10,20,10);
scene.add(dirLight);

// Floor
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(50,50),
  new THREE.MeshPhongMaterial({color:0x00ff00})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// Targets
const targets=[];
for(let x=5;x<=25;x+=10){
  const t = new THREE.Mesh(
    new THREE.BoxGeometry(1,1,1),
    new THREE.MeshPhongMaterial({color:0xff0000})
  );
  t.position.set(x,0.5,-5);
  t.health=100;
  t.userData.falling=false;
  scene.add(t);
  targets.push(t);
}

// Weapon placeholder cube
const weapon = new THREE.Mesh(
  new THREE.BoxGeometry(0.2,0.2,1),
  new THREE.MeshPhongMaterial({color:0x000000})
);
weapon.position.set(0,-0.2,-0.5);
camera.add(weapon);
scene.add(camera);

// Player
const player={speed:0.2,jump:0.3,yVel:0,onGround:true};
const keys={};
document.addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
document.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

// Score
let score=0;
const scoreDiv = document.getElementById('score');

// Bullets
const bullets=[];

// Shoot
function shoot(){
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.05,8,8),
    new THREE.MeshBasicMaterial({color:0xffff00})
  );
  bullet.position.copy(camera.position);
  bullet.direction = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  bullets.push(bullet);
  scene.add(bullet);
}
window.addEventListener('mousedown',shoot);

// Animate
function animate(){
  requestAnimationFrame(animate);

  // Movement
  const dir = new THREE.Vector3();
  if(keys['w']) dir.z -=1;
  if(keys['s']) dir.z +=1;
  if(keys['a']) dir.x -=1;
  if(keys['d']) dir.x +=1;
  dir.normalize().multiplyScalar(player.speed);
  camera.position.x+=dir.x;
  camera.position.z+=dir.z;

  // Jump
  if(keys[' '] && player.onGround){
    player.yVel=player.jump;
    player.onGround=false;
  }
  player.yVel-=0.01;
  camera.position.y+=player.yVel;
  if(camera.position.y<1.6){ camera.position.y=1.6; player.yVel=0; player.onGround=true; }

  // Bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.position.add(b.direction.clone().multiplyScalar(0.5));

    for(const t of targets){
      if(!t.userData.falling && b.position.distanceTo(t.position)<0.6){
        t.health-=100;
        if(t.health<=0) t.userData.falling=true;
        score+=100;
        scoreDiv.innerText = `Score: ${score}`;
        scene.remove(b);
        bullets.splice(i,1);
        break;
      }
    }
    if(bullets[i] && b.position.distanceTo(camera.position)>50){
      scene.remove(bullets[i]);
      bullets.splice(i,1);
    }
  }

  // Falling targets
  for(const t of targets){
    if(t.userData.falling){
      t.position.y-=0.1;
      t.rotation.x+=0.05;
      t.rotation.z+=0.05;
      if(t.position.y<-5){
        scene.remove(t);
        targets.splice(targets.indexOf(t),1);
      }
    }
  }

  renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
