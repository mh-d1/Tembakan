<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Three.js Shooter Full</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block; }
  #crosshair{
    position:absolute;
    top:50%;
    left:50%;
    width:10px;
    height:10px;
    margin-left:-5px;
    margin-top:-5px;
    border:2px solid black;
    border-radius:50%;
    pointer-events:none;
    z-index:10;
  }
  #mobileControls{
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    display:flex;
    gap:10px;
  }
  .btn{
    width:50px; height:50px;
    background:rgba(0,0,0,0.5);
    color:white;
    text-align:center;
    line-height:50px;
    border-radius:50%;
    user-select:none;
  }
</style>
</head>
<body>
<div id="crosshair"></div>
<div id="mobileControls">
  <div class="btn" id="up">↑</div>
  <div class="btn" id="down">↓</div>
  <div class="btn" id="left">←</div>
  <div class="btn" id="right">→</div>
  <div class="btn" id="jump">⤴</div>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js';

// Scene & Camera
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0,1.6,10);

// Renderer
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Cahaya
scene.add(new THREE.AmbientLight(0xffffff,1));
const dirLight = new THREE.DirectionalLight(0xffffff,0.5);
dirLight.position.set(10,20,10);
scene.add(dirLight);

// Lantai hijau
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(50,50),
  new THREE.MeshPhongMaterial({color:0x00ff00})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// Balok penghalang
const obstacles=[];
for(let x=5;x<=25;x+=10){
  const obs = new THREE.Mesh(
    new THREE.BoxGeometry(2,2,1),
    new THREE.MeshPhongMaterial({color:0x888888})
  );
  obs.position.set(x-2,1,0);
  scene.add(obs);
  obstacles.push(obs);
}

// Target merah
const targets=[];
for(let x=5;x<=25;x+=10){
  const t = new THREE.Mesh(
    new THREE.BoxGeometry(1,1,1),
    new THREE.MeshPhongMaterial({color:0xff0000})
  );
  t.position.set(x,0.5,-5);
  t.health=100;
  scene.add(t);
  targets.push(t);
}

// Player
const player={speed:0.2,jump:0.3,yVel:0,onGround:true};
const keys={};

// Keyboard
document.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
document.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

// Mobile
['up','down','left','right','jump'].forEach(id=>{
  document.getElementById(id).addEventListener('touchstart',()=>keys[id]=true);
  document.getElementById(id).addEventListener('touchend',()=>keys[id]=false);
});

// Shoot
function shoot(){
  const ray = new THREE.Raycaster();
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  ray.set(camera.position, dir);
  const hits = ray.intersectObjects(targets);
  if(hits.length>0){
    const t = hits[0].object;
    t.health-=100;
    if(t.health<=0){
      scene.remove(t);
      targets.splice(targets.indexOf(t),1);
    }
  }
}
window.addEventListener('mousedown', shoot);

// Animate
function animate(){
  requestAnimationFrame(animate);

  // Movement
  const dir = new THREE.Vector3();
  if(keys['w']||keys['up']) dir.z -=1;
  if(keys['s']||keys['down']) dir.z +=1;
  if(keys['a']||keys['left']) dir.x -=1;
  if(keys['d']||keys['right']) dir.x +=1;

  dir.normalize().multiplyScalar(player.speed);
  camera.position.x += dir.x;
  camera.position.z += dir.z;

  // Jump
  if((keys[' ' ]||keys['jump']) && player.onGround){
    player.yVel=player.jump;
    player.onGround=false;
  }
  player.yVel -=0.01;
  camera.position.y += player.yVel;
  if(camera.position.y<1.6){
    camera.position.y=1.6;
    player.yVel=0;
    player.onGround=true;
  }

  renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
